import groovy.json.JsonOutput

apply plugin: "groovy"
apply plugin: "java"
apply plugin: "application"
apply plugin: "idea"

/**************************************************
 *
 * SETUP
 *
 **************************************************/
buildscript {
    ext {
        groovyVersion = '2.4.3'
    }
    repositories {
        mavenCentral()
        mavenLocal()
        maven { url 'http://repo.spring.io/milestone' }
        maven { url 'https://repo.spring.io/snapshot' }
        maven { url "https://jitpack.io" }
    }
    dependencies {
        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.8.2'
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.8"
    }
}

wrapper {
    gradleVersion = '4.10.3'
}

configurations.all {
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

/*************************
 * SOURCE SET
 *************************/
sourceSets {
    main {
        groovy {
            srcDirs = ['src/main/java']
        }
    }

    test {
        groovy {
            srcDirs = ['src/test/java']
        }
    }
}

/**************************************************
 *
 * Define Variable&Function
 *
 **************************************************/
sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

String projectName = "installer-maker-cli"
version = "git describe --tags".execute([], project.projectDir).text.trim()
applicationName = "installer-maker"
group = "jaemmisseo"
mainClassName = "com.jaemisseo.install.application.InstallerMakerCliApplication"

String distributionPath = "${buildDir}/distributions"
String libFileName = "${projectName}-${version}"
String SystemEnv_INSTALLER_MAKER_HOME = "$System.env.INSTALLER_MAKER_HOME"
String deployDefaultPath = System.properties["user.home"] + "/installer-maker"
String deployPath = SystemEnv_INSTALLER_MAKER_HOME ?: deployDefaultPath
////TODO: 임시
//deployPath += "-test001"
boolean modeRemoteDependencies = project.hasProperty('remote')
boolean hadDeployment = false
List<Dependency> moduleList = []


ext.setProperty('coreBasePath', ':job:hoya:hoya-core')

ext.getString = { String propertyName -> return project.hasProperty(propertyName) ? project.property(propertyName) : null }
ext.getBoolean = { String propertyName -> return project.hasProperty(propertyName) && (!project.property(propertyName) || project.property(propertyName) == 'true') }
ext.getDependency = { String dependencyString ->
    String name = dependencyString.split(':').toList()[1]
//    println "121123t,3tkwtpr3proqc.rqwci0wq.c0e2"
    println modeRemoteDependencies
    println dependencyString
    println name
    return (modeRemoteDependencies) ? dependencyString : project(":job:hoya:hoya-core:${name}")
}

static void printSubject(String subjectName){
    println "\n========================="
    println "= ${subjectName}"
    println "========================="
}

static int getLongestLength(List list, String fieldName){
    return getLongestLength( list.collect{it[fieldName]} )
}

static int getLongestLength(List<String> list){
    int longestLength = -1
    list.each{ def text ->
        int length = text?.length() ?: 0
        if (longestLength < length)
            longestLength = length
    }
    return longestLength
}

static String getSpacesToLineUp(String stringItem, int bestLongerLength){
    if (stringItem == null)
        return ''
    return (stringItem.length() < bestLongerLength) ? (1..(bestLongerLength - stringItem.length())).collect{' '}.join('') : ''
}

static Dependency getDependencyFromDependencyString(String dependencyString){
    List projectItems = dependencyString.split(':').toList()
    return new Dependency(dependencyString: dependencyString, path:projectItems[0], name:projectItems[1], branchName:'', version:projectItems[2] ?: '')
}

static String getUserSetedVersionFromModuleList(List dependencyStringList, String moduleName){
    String dependencyString = dependencyStringList.find{ String dependencyString ->
        Dependency dependency = getDependencyFromDependencyString(dependencyString)
        return dependency.name == moduleName
    }
    return (dependencyString) ?: ''
}

class Dependency {
    String dependencyString
    String path
    String name
    String branchName
    String version
    String module
}



/**************************************************
 *
 * Dependencies
 *
 **************************************************/
repositories {
    mavenCentral()
    jcenter()
    maven { url "http://central.maven.org/maven2/" }
    maven { url "https://jitpack.io" }
    maven { url 'http://repo.spring.io/milestone' }
    maven { url "http://maven.springframework.org/release" }
}

dependencies {

    compile project(":job:hoya")
    compile project(':job:installer')
    compile project(':job:installer-maker')

    //Test
    testCompile "junit:junit:4.11"

    /** Local File System으로부터 참조(*.jar) **/
    compile fileTree(dir: 'external_lib', include: ['*.jar'])
    compile fileTree(dir: 'external_lib_dev', include: ['*.jar'])
}

//- (JAR빌드시) 개발용 개발시에만 필요한(배포시에는 필요없는) 파일 제외하기
jar.rootSpec.exclude( fileTree(dir: 'external_lib_dev', include: ['*.jar']).collect{ "**/${it.name}" } )





/**************************************************
 *
 * Setup All Projects
 *
 **************************************************/
allprojects {
    apply plugin: 'com.github.kt3k.coveralls'
    apply plugin: 'jacoco'
    apply plugin: 'org.sonarqube'
}

/**************************************************
 *
 * Setup Each Sub Projects
 *
 **************************************************/
subprojects {

    /*************************
     * Gethering Module's Git Info
     *************************/
    moduleList << new Dependency(
            name        : project.name,
            module      : project,
//            branchName  : 'git rev-parse --abbrev-ref HEAD'.execute([], project.projectDir).text.trim(),
//            version     : 'git describe --tags'.execute([], project.projectDir).text.trim()
    )
    group = 'jaemmisseo'
    version = moduleList[(moduleList.size()-1)].version

    //Message to Sub Gradle
    ext.setProperty('modeParentRemoteDependencies', modeRemoteDependencies)

    /** jacocoTestReport to Submodules **/
    jacocoTestReport {
        reports {
            html.enabled = true
            xml.enabled = true
            csv.enabled = false
            //to create coverage report in html
            html.destination file("${buildDir}/reports/coverage")
            //for XML
            xml.destination file("${buildDir}/reports/jacoco.xml")
        }
    }

    /** SonarQube **/
    sonarqube {
        properties {
            property "sonar.sourceEncoding", "UTF-8"
            // 프로젝트별로 달라지는 설정들
            property "sonar.sources", "src/main/java"
//            property "sonar.exclusions", "**/*Generated.java"
            property "sonar.branch", "Foo"
            property "sonar.junit.reportPaths", "${buildDir}/test-results"
            property "sonar.jacoco.reportPaths", "${buildDir}/jacoco/test.exec"
            property 'sonar.coverage.jacoco.xmlReportPaths', "${project.buildDir}/reports/jacoco.xml"
            // deprecated된 프로퍼티는 경고가 나오기에 제거하였다.
//            property "sonar.jacoco.reportPath", null
//            property "sonar.jacoco.reportPaths", null
        }
    }
}

if (modeRemoteDependencies){
    moduleList = subprojectList.collect{ String dependencyString -> getDependencyFromDependencyString(dependencyString) }
}



/**************************************************
 *
 * Print Information
 *
 **************************************************/
/*************************
 * Print Java Version
 *************************/
printSubject "Check - Java"
println ' - Compile Environment '
exec{ executable 'java';  args "-version"; }

/*************************
 * Print Module's Git Info
 *************************/
printSubject "Check - Git"
// Get best long length 'moduleName' and 'branchName' to adjust spacing
int bestLongModuleNameLength = getLongestLength(moduleList, 'name')
int bestLongBranchNameLength = getLongestLength(moduleList, 'branchName')
// Adjust spacing And Print Git Module, Branch, Version
moduleList.each{ Dependency module ->
    String moduleNameSpace = getSpacesToLineUp(module.name, bestLongModuleNameLength)
    String branchNameSpace = getSpacesToLineUp(module.branchName, bestLongBranchNameLength)
    println " - ${module.name}${moduleNameSpace} (${module.branchName})${branchNameSpace} Version. ${module.version}"
}

/*************************
 * Print Build Options
 *************************/
printSubject "Check - Build Option"
// Print
println "[${modeRemoteDependencies?'v':' '}] Remote Dependencies Mode( -Premote )"

/*************************
 * Print Next
 *************************/
printSubject "Check - Start Task"



/**************************************************
 *
 * Tasks 
 *
 **************************************************/

/*************************
 *
 * TASK - jacoco to report coverage
 *
 *************************/
// 각 서브모듈들의 JacocoReport 취합
task jacocoRootReport(type: JacocoReport) {
    description = 'Generates an aggregate report from all subprojects'
//    dependsOn = subprojects.test
//    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
//    classDirectories =  files(subprojects.sourceSets.main.output)
//    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        html.enabled = true // human readable
        xml.enabled = true // required by coveralls
        csv.enabled = false
        html.destination file("${buildDir}/reports/coverage")
        xml.destination file("${buildDir}/reports/jacoco.xml")
    }
}

/** coveralls Task로 jacocoRootReport 로 취합된 결과만 전송 **/
coveralls {
    sourceDirs = subprojects.sourceSets.main.allSource.srcDirs.flatten()
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}



/*************************
 *
 * TASK - jar
 *
 *************************/
/** Before jar **/
task writeVersion {
    doFirst{
        printSubject "Generate - metadata"
        File[] files = new File("$buildDir/resources/main").listFiles()
        printSubject "Count ($buildDir/resources/main): ${files.length}"
        files?.each{
            println it.name
        }
    }
    doLast{
        new File("$buildDir/resources/main/.version").write(version)
        new File("$buildDir/resources/main/.compiler").write("Java ${System.getProperty('java.version')}")
        new File("$buildDir/resources/main/.date").write(new Date().toString())
        new File("$buildDir/resources/main/.libtohome").write('../')
        new File("$buildDir/resources/main/.version").write(version)
    }
}

task copyHoyaTargetClasses(type: Copy) {
    doFirst{
        printSubject "Copy - Hoya's target classes"
    }
    from "${buildDir}/scan-target-classes"
    into "${buildDir}/resources/main/scan-target-classes"
    doLast{
        new File("${buildDir}/resources/main/scan-target-classes").listFiles().each{ println it }
        println ""
    }
}

jar {
    dependsOn copyHoyaTargetClasses, writeVersion

    /** MANIFEST **/
    manifest {
        attributes  'Title': projectName, 'Version': version, 'Main-Class': mainClassName
    }

    /** Jarfile Name **/
    archiveName "${libFileName}.jar"

    /** Extracted All Dependencies To jar **/
//    dependsOn configurations.runtime
//    from {
//        configurations.compile.collect {it.isDirectory()? it: zipTree(it)}
//    }

    /** All Dependencies to lib folder in jar **/
//    into('lib') {
//        from configurations.runtime
//    }
}

/*************************
 *
 * TASK - distZIp
 *
 *************************/
/** Before distZip **/
distributions{
    main.contents.into("bin"){
        from([
                "${project(":job:hoya").projectDir.path}/src/main/resources/binForHoya/hoya",
                "${project(":job:hoya").projectDir.path}/src/main/resources/binForHoya/hoya.bat",
        ])
        fileMode 0755
    }
}

distZip {
    archiveName "${libFileName}.zip"
    doLast{
        printSubject "Check - Distribution (Path: ${distributionPath} )"
        new File(distributionPath).listFiles().each{ println it }
    }
}

/*************************
 *
 * TASK - distTar
 *
 *************************/
distTar {
    archiveName "${libFileName}.tar"
    doLast{
        printSubject "Check - Distribution (Path: ${distributionPath} )"
        new File(distributionPath).listFiles().each{ println it }
    }
}


/*************************
 *
 * TASK - build
 *
 *************************/
/** Before build **/
task extractZipToTemp(type: Copy){
    from zipTree("${distributionPath}/${libFileName}.zip")
    into "${distributionPath}"
    doLast{
        file("${distributionPath}/${libFileName}").renameTo(file("${distributionPath}/${projectName}"))
    }
}

build.dependsOn extractZipToTemp, copyHoyaTargetClasses, writeVersion


/*************************
 *
 * TASK - deployLocal
 *  - Deploy to INSTALLER_MAKER_HOME
 *
 *************************/
/** Before deployLocal **/
task cleanHome(type: Delete){
    hadDeployment = new File(deployPath).exists()
    delete deployPath
    doLast{
        if (hadDeployment){
            printSubject "Deleted Before-Deployment!!! (Path: ${deployPath} )"
        }
    }
}

task deployLocal(type: Copy){
    dependsOn distZip, extractZipToTemp, cleanHome
    from "${distributionPath}/${projectName}"
    into deployPath
    doLast{
        printSubject "${(hadDeployment)?'Re-Deployed':'Newly-Deployed'} !!! (Path: ${deployPath} )"
        new File(deployPath).listFiles().each{ println it }
    }
}


